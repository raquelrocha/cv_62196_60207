/**
 * Change Detection project.
 * Catarina Bastos 60207
 * Raquel Rocha 62196
 * Computação Visual 2016/2017
 * Universidade de Aveiro
 */

//opencv
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include <opencv2/highgui.hpp>
#include <opencv2/tracking.hpp>
#include <opencv2/video.hpp>
#include "opencv2/objdetect.hpp"

//C
#include <stdio.h>
//C++
#include <iostream>
#include <sstream>

using namespace cv;
using namespace std;

// Global variables
Mat frame; //current/captured frame
Mat fgMaskMOG2; //foreground mask generated by MOG2 method
Mat frame_gray; //captured frame in gray

Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor

vector<Ptr<Tracker> > trackers; //Vector to save traking information
vector<Rect2d> intruders; //Vector to save the recognized intruders

String face_cascade_name = "haarcascade_frontalface_alt.xml"; // Face cascade XML file
CascadeClassifier face_cascade;
vector<Rect> faces; //Vector to save the recognized faces

string text = "Unoccupied"; //Feedback text

char keyboard; //input from keyboard

void processVideo();
double overlapPercentage(const Rect& A, const Rect2d& B);


/**
 * This program detects changes and faces in a room,
 * giving feedback in the form of text (Occupied/Unoccupied)
 * and rectangles (Red for faces, Blue for intruders).
 *
 * @function main
 */
int main(int argc, char* argv[])
{
    cout << "Press ESC or q to end program execution" << endl;
    //Create GUI windows
    namedWindow("Frame");

    //Create Background Subtractor objects
    pMOG2 = createBackgroundSubtractorMOG2(1000, 16, false); //MOG2 approach

    //Load Face Cascade XML
    if( !face_cascade.load( face_cascade_name ) ){ printf("--(!)Error loading face cascade\n"); return -1; };

    //Process Video
    processVideo();

    //destroy GUI windows
    destroyAllWindows();

    return EXIT_SUCCESS;
}

/**
 * @function processVideo
 */
void processVideo()
{
    VideoCapture capture(0); //Create the capture object

    if(!capture.isOpened()){ //error in opening the video input
        cerr << "Unable to open camera" << endl;
        exit(EXIT_FAILURE);
    }

    //Read keyboard input data. ESC or 'q' for quitting
    keyboard = 0;

    capture.read(frame); //First frame

    //Create the output video
    int fourcc = static_cast<int>(capture.get(CV_CAP_PROP_FOURCC));
    VideoWriter outputVideo;
    Size frameSize((int) capture.get(CV_CAP_PROP_FRAME_WIDTH), (int) capture.get(CV_CAP_PROP_FRAME_HEIGHT));
    outputVideo.open("cv.wmv", fourcc, 15, frameSize, true);


    int intruder_area_threshold = (int)floor(frame.size().height * frame.size().width * 0.05);  //Threshold for the intruder recognition area

    while( keyboard != 'q' && keyboard != 27 ){
        //read the current frame
        if(!capture.read(frame)) {
            cerr << "Unable to read next frame." << endl;
            cerr << "Exiting..." << endl;
            exit(EXIT_FAILURE);
        }

        // Gray convertion of original frame for face detection
        cvtColor( frame, frame_gray, COLOR_BGR2GRAY );
        equalizeHist( frame_gray, frame_gray );

        //Face Detection
        face_cascade.detectMultiScale( frame_gray, faces, 1.1, 2, 0|CASCADE_SCALE_IMAGE, Size(30, 30) );

        //Update the background model (fgMaskMog2)
        pMOG2->apply(frame, fgMaskMOG2);

        //Vectors to be used in findContours
        vector<vector<Point> > contours;
        vector<Vec4i> hierarchy;

        //Find contours of the background model
        findContours(fgMaskMOG2,contours,hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);

        Rect box;
        for(vector<Point> c : contours){
            if(contourArea(c) < 1000.0) {
                text = "Unoccupied";
                continue;
            }
            else {
                box = boundingRect(c);
                if(box.size().width*box.size().height > intruder_area_threshold) { //Verify if the box respects the threshold defined above
                    /**
                     * For each contoured box, it verifies the overlap percentage with existing intruders.
                     * In case it overlaps in more than 10%, the existing intruder is removed and updated
                     * with the respective box.
                     */
                    for (unsigned long i = 0; i < trackers.size(); i++) {
                        if (overlapPercentage(box, intruders[i]) > 0.1) {
                            intruders.erase(intruders.begin() + i);
                            trackers.erase(trackers.begin() + i);
                            i--;
                        }
                    }
                    trackers.push_back(Tracker::create("KCF"));
                    intruders.push_back(Rect2d(box));
                    trackers[trackers.size() - 1]->init(frame, box);

                }

            }
        }

        for(unsigned long i =0; i<trackers.size(); i++)
        {
            trackers[i]->update(frame, intruders[i]);

            /**
             * Verify if the intruder is exiting the frame.
             * It will be removed if it is.
             */

            if(intruders[i].y + intruders[i].height > frame.size().height || intruders[i].y < 0 ||
               intruders[i].x + intruders[i].width > frame.size().width || intruders[i].x < 0)
            {
                intruders.erase(intruders.begin()+i);
                trackers.erase(trackers.begin()+i);
                i--;
            }
            else
            {
                //Verify if an intruder is a person or not, based in the face recognition vector (faces).
                bool is_person = false;
                for ( size_t i = 0; i < faces.size(); i++ )
                {
                    Point center( faces[i].x + faces[i].width/2, faces[i].y + faces[i].height/2 );

                    if(center.x > intruders[i].x && center.x < intruders[i].x+intruders[i].width &&
                       center.y > intruders[i].y && center.y < intruders[i].y + intruders[i].height) {
                        is_person = true;
                        break;
                    }
                }
                /**
                 * Add change detection feedback (rectangles) to the frame.
                 * Red rectangle for face detection. Blue Rectangle otherwise (for change detection).
                 */
                rectangle(frame, intruders[i], is_person ? Scalar(0, 0, 255) : Scalar(255, 0, 0) , 2);
                text = "Occupied";
            }
        }

        // Add textual feedback to the frame
        putText(frame, "Room Status: "+text, Point(10,20), FONT_HERSHEY_SIMPLEX, 0.5, (0,0,255),2);

        // Show the current frame with respective feedback
        imshow("Frame", frame);

        // Saves the frame (output video)
        outputVideo << frame;

        // Get the input from the keyboard
        keyboard = (char)waitKey( 1 );
    }

    //Delete capture and output object
    capture.release();
    outputVideo.release();
}

/**
 * Function to verify if the overlap percentage of A within B
 * @param A
 * @param B
 * @return A double that represents the overlap percentage of A in B
 */
double overlapPercentage(const Rect& A, const Rect2d& B){
    int x_overlap = max(0, min(A.x+A.width,(int)B.x + (int)B.width) - max(A.x,(int)B.x));
    int y_overlap = max(0, min(A.y+A.height,(int)B.y + (int)B.height) - max(A.y,(int)B.y));
    int overlapArea = x_overlap * y_overlap;
    return (double)overlapArea/(A.width*A.height);
}