//opencv
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include <opencv2/highgui.hpp>
#include <opencv2/video.hpp>
//C
//C++
#include <iostream>

using namespace cv;
using namespace std;
// Global variables
Mat frame,gray; //fg mask fg mask generated by MOG2 method
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
string text = "Unoccupied";
int keyboard; //input from keyboard

time_t firstClk, secClk;

void processVideo(char* videoFileName);

int main(int argc, char* argv[])
{

    //create Background Subtractor objects
    pMOG2 = createBackgroundSubtractorMOG2(500,25,true); //MOG2 approach

    processVideo(argv[1]);

    //destroy GUI windows
    destroyAllWindows();
    return EXIT_SUCCESS;
}

void processVideo(char* videoFileName) {
    //create the capture object
    //VideoCapture capture("people-walking.mp4");
    VideoCapture capture(0);
    if(!capture.isOpened()){
        //error in opening the video input
        cerr << "Unable to capture video" << endl;
        exit(EXIT_FAILURE);
    }
    //read input data. ESC or 'q' for quitting

    time(&firstClk);
    while( ((char)keyboard != 'q' || (char)keyboard != 'Q') && (char)keyboard != 27 ){
        //read the current frame
        if(!capture.read(frame)) {
            cerr << "Unable to read next frame." << endl;
            cerr << "Exiting..." << endl;
            exit(EXIT_FAILURE);
        }

        //update the background model
        resize(frame,frame,Size(500,500));

        pMOG2->apply(frame, fgMaskMOG2);
        imshow("C sombras", fgMaskMOG2);

        cvtColor(frame,gray, COLOR_BGR2GRAY);
        medianBlur(gray, gray, 21);

        Mat frameDelta, tresh;
        absdiff(fgMaskMOG2,gray,frameDelta);
        threshold(frameDelta,fgMaskMOG2,25,255,CV_THRESH_BINARY);

        dilate(fgMaskMOG2,fgMaskMOG2,getStructuringElement(MORPH_ELLIPSE, Size(3, 3)));
        erode(fgMaskMOG2,fgMaskMOG2, getStructuringElement(MORPH_ELLIPSE, Size(3,3)));



        vector<vector<Point> > contours;
        vector<Vec4i> hierarchy;
        findContours(fgMaskMOG2,contours,hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);
        Rect box;
        for(vector<Point> c : contours){
            if(contourArea(c) < 00.0) {
                text = "Unoccupied";
                continue;
            }
            box = boundingRect(c);
            rectangle(frame,Point(box.x,box.y), Point(box.x + box.width - 20, box.y + box.height -20), (0,255,0),2);
            text = "Occupied";
        }

        time_t rawtime;
        struct tm * timeinfo;
        char buffer[80];

        time (&rawtime);
        timeinfo = localtime(&rawtime);

        strftime(buffer,80,"%d-%m-%Y %I:%M:%S",timeinfo);
        std::string str(buffer);

        putText(frame, "Room Status: "+text, Point(10,20), FONT_HERSHEY_SIMPLEX, 0.5, (0,0,255),2);
        putText(frame, str, Point(10,frame.rows -10), FONT_HERSHEY_SIMPLEX,0.25,(0,0,255),1);

        imshow("Security Feed", frame);
       // imshow("Thresh", tresh);
        imshow("Frame Delta", frameDelta);


        //get the input from the keyboard
        keyboard = waitKey( 30 );
    }
    //delete capture object
    capture.release();
}